{"ast":null,"code":"import { each, isString } from 'underscore';\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\nimport XRegExp from \"xregexp\";\nwindow.nodeHtmlParser = nodeHtmlParser;\n/**\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\n *\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\n *\n * @param config usual grapesjs config\n * @returns parser function\n */\n\nexport default (function (config) {\n  var TEXT_NODE = 'span';\n  var c = config;\n  var modelAttrStart = 'data-gjs-';\n  return {\n    compTypes: '',\n    modelAttrStart: modelAttrStart,\n\n    /**\n     * Extract component props from an attribute object\n     * @param {Object} attr\n     * @returns {Object} An object containing props and attributes without them\n     */\n    splitPropsFromAttr: function splitPropsFromAttr() {\n      var _this = this;\n\n      var attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = {};\n      var attrs = {};\n      each(attr, function (value, key) {\n        if (key.indexOf(_this.modelAttrStart) === 0) {\n          var modelAttr = key.replace(modelAttrStart, '');\n          var valueLen = value.length;\n          var valStr = value && isString(value);\n          var firstChar = valStr && value.substr(0, 1);\n          var lastChar = valStr && value.substr(valueLen - 1);\n          value = value === 'true' ? true : value;\n          value = value === 'false' ? false : value; // Try to parse JSON where it's possible\n          // I can get false positive here (eg. a selector '[data-attr]')\n          // so put it under try/catch and let fail silently\n\n          try {\n            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;\n          } catch (e) {}\n\n          props[modelAttr] = value;\n        } else {\n          attrs[key] = value;\n        }\n      });\n      return {\n        props: props,\n        attrs: attrs\n      };\n    },\n\n    /**\n     * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\n     * actual HTML attributes\n     * @param {*} html\n     * @return html with quoted JSX attributes\n     *\n     * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\n     */\n    quoteJsxExpresionsInAttributes: function quoteJsxExpresionsInAttributes(html) {\n      var found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\n\n      for (var i = 0; i < found.length; i++) {\n        // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\n        // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n        var pattern = \"{\" + found[i] + \"}\";\n        var lastStartPos = 0; // Find pattern until we reach and of html\n\n        while (true) {\n          var needsQuote = false; // get next match position\n\n          var matchPos = html.indexOf(pattern, lastStartPos);\n\n          if (matchPos === -1) {\n            break;\n          } // We will look back 1 and 2 characters\n\n\n          var oneCharBeforePos = matchPos - 1;\n          var twoCharBeforePos = matchPos - 2;\n\n          if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\n            // Need to quote if have sg like this:\n            //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n            // (ie: if patterns comes atfre and equals sime, but not =\")\n            // But no need to quote if:\n            //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\n            //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\n            needsQuote = html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' && html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\n          } // If need to quote: replace patterns with quoted version also escaping some HTML entities\n\n\n          if (needsQuote) {\n            var replacement = '\"{' + found[i].replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"&\", \"&amp;\") + '}\"';\n            html = html.replace(pattern, replacement);\n            lastStartPos = matchPos + replacement.length;\n          } else {\n            lastStartPos = matchPos + pattern.length;\n          } // No lastStartPos placed after the processed string\n\n        }\n      }\n\n      return html;\n    },\n\n    /**\n     * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\n     * @param html\n     */\n    unquoteJsxExpresionsInAttributes: function unquoteJsxExpresionsInAttributes(html) {\n      var found = html.match(/=[\"']{.*}[\"']/g);\n\n      if (!found) {\n        return html;\n      }\n\n      for (var i = 0; i < found.length; i++) {\n        var pattern = found[i];\n        var replacement = pattern.startsWith('=\"{') ? pattern.replace('\"{', \"{\").replace('}\"', \"}\") : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\n        replacement = replacement.replace(\"&lt;\", \"<\").replace(\"&gt;\", \">\").replace(\"&amp;\", \"&\");\n        html = html.replace(pattern, replacement);\n      }\n\n      return html;\n    },\n\n    /**\n     * Parse style string to object\n     * @param {string} str\n     * @return {Object}\n     * @example\n     * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\n     * console.log(stl);\n     * // {color: 'black', width: '100px', test: 'value'}\n     */\n    parseStyle: function parseStyle(str) {\n      var result = {};\n      var decls = str.split(';');\n\n      for (var i = 0, len = decls.length; i < len; i++) {\n        var decl = decls[i].trim();\n        if (!decl) continue;\n        var prop = decl.split(':');\n        result[prop[0].trim()] = prop.slice(1).join(':').trim();\n      }\n\n      return result;\n    },\n\n    /**\n     * Parse class string to array\n     * @param {string} str\n     * @return {Array<string>}\n     * @example\n     * var res = ParserHtml.parseClass('test1 test2 test3');\n     * console.log(res);\n     * // ['test1', 'test2', 'test3']\n     */\n    parseClass: function parseClass(str) {\n      var result = [];\n      var cls = str.split(' ');\n\n      for (var i = 0, len = cls.length; i < len; i++) {\n        var cl = cls[i].trim();\n        if (!cl) continue;\n        result.push(cl);\n      }\n\n      return result;\n    },\n    toAttrArray: function toAttrArray(obj) {\n      var attrArr = [];\n      Object.keys(obj).map(function (key) {\n        attrArr.push({\n          'nodeName': key,\n          'nodeValue': obj[key]\n        });\n      });\n      return attrArr;\n    },\n\n    /**\n     * Get data from the node element\n     * @param  {HTMLElement} el DOM element to traverse\n     * @return {Array<Object>}\n     */\n    parseNode: function parseNode(el) {\n      var result = [];\n      var nodes = el.childNodes;\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i]; // DOM copmatibility\n\n        node.nodeValue = node.rawText;\n        node.content = node.rawText; // Make attrs compatible with DOM representation\n\n        var attrs = [];\n        attrs = (typeof node.attributes == 'object' ? this.toAttrArray(node.attributes) : node.attributes) || [];\n        var attrsLen = attrs.length;\n        var nodePrev = result[result.length - 1];\n        var nodeChild = node.childNodes.length;\n        var ct = this.compTypes;\n        var model = {};\n\n        if (ct) {\n          var obj = '';\n          var type = node.getAttribute && node.getAttribute(\"\".concat(modelAttrStart, \"type\"));\n\n          if (!type) {\n            type = node.attributes && node.attributes[\"\".concat(modelAttrStart, \"type\")];\n          }\n\n          if (type) {\n            model = {\n              type: type\n            };\n          } else {\n            for (var it = 0; it < ct.length; it++) {\n              var compType = ct[it];\n              obj = compType.model.isComponent(node);\n\n              if (obj) {\n                if (typeof obj !== 'object') {\n                  obj = {\n                    type: compType.id\n                  };\n                }\n\n                break;\n              }\n            }\n\n            model = obj;\n          }\n        }\n\n        model.tagName = node.tagName;\n\n        if (attrsLen) {\n          model.attributes = {};\n        }\n\n        for (var j = 0; j < attrsLen; j++) {\n          var nodeName = attrs[j].nodeName;\n          var nodeValue = attrs[j].nodeValue; // if (nodeName == \"formatValue\") {\n          //     debugger;\n          // }\n          // Isolate attributes\n\n          if (nodeName == 'style') {\n            model.style = this.parseStyle(nodeValue);\n          } else if (nodeName == 'class') {\n            model.classes = this.parseClass(nodeValue);\n          } else if (nodeName == 'contenteditable') {\n            continue;\n          } else if (nodeName.indexOf(modelAttrStart) === 0) {\n            var modelAttr = nodeName.replace(modelAttrStart, '');\n            var valueLen = nodeValue.length;\n            var firstChar = nodeValue && nodeValue.substr(0, 1);\n            var lastChar = nodeValue && nodeValue.substr(valueLen - 1);\n            nodeValue = nodeValue === 'true' ? true : nodeValue;\n            nodeValue = nodeValue === 'false' ? false : nodeValue;\n\n            try {\n              nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;\n            } catch (e) {}\n\n            model[modelAttr] = nodeValue;\n          } else {\n            model.attributes[nodeName] = nodeValue;\n          }\n        }\n\n        if (nodeChild && !model.components) {\n          var firstChild = node.childNodes[0];\n          firstChild.nodeValue = firstChild.rawText;\n\n          if (nodeChild === 1 && firstChild.nodeType === 3) {\n            !model.type && (model.type = 'text');\n            model.content = firstChild.nodeValue;\n          } else {\n            model.components = this.parseNode(node);\n          }\n        }\n\n        if (model.type == 'textnode') {\n          model.content = node.nodeValue;\n\n          if (nodePrev && nodePrev.type == 'textnode') {\n            nodePrev.content += model.content;\n            continue;\n          }\n\n          if (!config.keepEmptyTextNodes) {\n            var content = node.nodeValue;\n\n            if (content != ' ' && !content.trim()) {\n              continue;\n            }\n          }\n        }\n\n        var comps = model.components;\n\n        if (!model.type && comps) {\n          var allTxt = 1;\n          var foundTextNode = 0;\n\n          for (var ci = 0; ci < comps.length; ci++) {\n            var comp = comps[ci];\n            var cType = comp.type;\n\n            if (['text', 'textnode'].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {\n              allTxt = 0;\n              break;\n            }\n\n            if (cType == 'textnode') {\n              foundTextNode = 1;\n            }\n          }\n\n          if (allTxt && foundTextNode) {\n            model.type = 'text';\n          }\n        }\n\n        if (!model.tagName && model.type != 'textnode') {\n          continue;\n        }\n\n        result.push(model);\n      }\n\n      return result;\n    },\n\n    /**\n     * Parse HTML string to a desired model object\n     * @param  {string} str HTML string\n     * @param  {ParserCss} parserCss In case there is style tags inside HTML\n     * @return {Object}\n     *\n     */\n    parse: function parse(str, parserCss) {\n      console.log(\"html\", str, parserCss);\n      var config = c.em && c.em.get('Config') || {};\n      var res = {\n        html: '',\n        css: ''\n      };\n      var quoted = this.quoteJsxExpresionsInAttributes(str);\n      var wrappedInDiv = false;\n\n      if (!quoted.startsWith('<')) {\n        quoted = '<div>' + quoted + '</div>';\n        wrappedInDiv = true;\n      }\n\n      var dom = nodeHtmlParser(quoted);\n      var result = this.parseNode(dom);\n\n      if (result.length == 1) {\n        result = result[0];\n      }\n\n      if (wrappedInDiv) {\n        if (result.components) {\n          result = result.components;\n        } else {\n          delete result.tagName;\n          result.type = \"textnode\";\n        }\n      }\n\n      res.html = result;\n\n      if (parserCss) {\n        var el = document.createElement('div');\n        el.innerHTML = str;\n        var styleStr = '';\n        var styles = el.querySelectorAll('style');\n        var j = styles.length;\n\n        while (j--) {\n          styleStr = styles[j].innerHTML + styleStr;\n          styles[j].parentNode.removeChild(styles[j]);\n        }\n\n        if (styleStr) res.css = parserCss.parse(styleStr);\n      }\n\n      return res;\n    }\n  };\n});","map":{"version":3,"sources":["/Users/imustafa/Projects/LoStudio/client/components/grapes/chart-widgets/line-chart/ParserHtmlCaseSensitive.js"],"names":["each","isString","parse","nodeHtmlParser","XRegExp","window","config","TEXT_NODE","c","modelAttrStart","compTypes","splitPropsFromAttr","attr","props","attrs","value","key","indexOf","modelAttr","replace","valueLen","length","valStr","firstChar","substr","lastChar","JSON","e","quoteJsxExpresionsInAttributes","html","found","matchRecursive","i","pattern","lastStartPos","needsQuote","matchPos","oneCharBeforePos","twoCharBeforePos","substring","replacement","unquoteJsxExpresionsInAttributes","match","startsWith","parseStyle","str","result","decls","split","len","decl","trim","prop","slice","join","parseClass","cls","cl","push","toAttrArray","obj","attrArr","Object","keys","map","parseNode","el","nodes","childNodes","node","nodeValue","rawText","content","attributes","attrsLen","nodePrev","nodeChild","ct","model","type","getAttribute","it","compType","isComponent","id","tagName","j","nodeName","style","classes","components","firstChild","nodeType","keepEmptyTextNodes","comps","allTxt","foundTextNode","ci","comp","cType","textTags","parserCss","console","log","em","get","res","css","quoted","wrappedInDiv","dom","document","createElement","innerHTML","styleStr","styles","querySelectorAll","parentNode","removeChild"],"mappings":"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","sourcesContent":["import { each, isString } from 'underscore';\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\nimport XRegExp from \"xregexp\";\n\nwindow.nodeHtmlParser = nodeHtmlParser;\n\n/**\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\n *\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\n *\n * @param config usual grapesjs config\n * @returns parser function\n */\nexport default config => {\n    var TEXT_NODE = 'span';\n    var c = config;\n    var modelAttrStart = 'data-gjs-';\n\n    return {\n        compTypes: '',\n\n        modelAttrStart,\n\n        /**\n         * Extract component props from an attribute object\n         * @param {Object} attr\n         * @returns {Object} An object containing props and attributes without them\n         */\n        splitPropsFromAttr(attr = {}) {\n            const props = {};\n            const attrs = {};\n\n            each(attr, (value, key) => {\n                if (key.indexOf(this.modelAttrStart) === 0) {\n                    const modelAttr = key.replace(modelAttrStart, '');\n                    const valueLen = value.length;\n                    const valStr = value && isString(value);\n                    const firstChar = valStr && value.substr(0, 1);\n                    const lastChar = valStr && value.substr(valueLen - 1);\n                    value = value === 'true' ? true : value;\n                    value = value === 'false' ? false : value;\n\n                    // Try to parse JSON where it's possible\n                    // I can get false positive here (eg. a selector '[data-attr]')\n                    // so put it under try/catch and let fail silently\n                    try {\n                        value =\n                            (firstChar == '{' && lastChar == '}') ||\n                            (firstChar == '[' && lastChar == ']')\n                                ? JSON.parse(value)\n                                : value;\n                    } catch (e) {}\n\n                    props[modelAttr] = value;\n                } else {\n                    attrs[key] = value;\n                }\n            });\n\n            return {\n                props,\n                attrs\n            };\n        },\n\n        /**\n         * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\n         * actual HTML attributes\n         * @param {*} html\n         * @return html with quoted JSX attributes\n         *\n         * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\n         */\n        quoteJsxExpresionsInAttributes(html) {\n            let found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\n            for (let i = 0; i < found.length; i++) {\n                // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\n                // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n                let pattern = \"{\" + found[i] + \"}\";\n                let lastStartPos = 0;\n                // Find pattern until we reach and of html\n                while (true) {\n                    let needsQuote = false;\n                    // get next match position\n                    let matchPos = html.indexOf(pattern, lastStartPos);\n                    if (matchPos === -1) {\n                        break;\n                    }\n                    // We will look back 1 and 2 characters\n                    let oneCharBeforePos = matchPos - 1;\n                    let twoCharBeforePos = matchPos - 2;\n                    if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\n                        // Need to quote if have sg like this:\n                        //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n                        // (ie: if patterns comes atfre and equals sime, but not =\")\n                        // But no need to quote if:\n                        //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\n                        //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\n                        needsQuote =\n                            html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' &&\n                            html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\n                    }\n\n                    // If need to quote: replace patterns with quoted version also escaping some HTML entities\n                    if (needsQuote) {\n                        let replacement =\n                            '\"{' +\n                            found[i]\n                                .replace(\"<\", \"&lt;\")\n                                .replace(\">\", \"&gt;\")\n                                .replace(\"&\", \"&amp;\")\n                            + '}\"';\n                        html = html.replace(pattern, replacement);\n                        lastStartPos = matchPos + replacement.length;\n                    } else {\n                        lastStartPos = matchPos + pattern.length;\n                    }\n\n                    // No lastStartPos placed after the processed string\n                }\n            }\n            return html;\n        },\n\n\n\n        /**\n         * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\n         * @param html\n         */\n        unquoteJsxExpresionsInAttributes(html) {\n            let found = html.match(/=[\"']{.*}[\"']/g);\n            if (!found) {\n                return html;\n            }\n            for (let i = 0; i < found.length; i++) {\n                let pattern = found[i];\n                let replacement = pattern.startsWith('=\"{')\n                    ? pattern.replace('\"{', \"{\").replace('}\"', \"}\")\n                    : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\n                replacement = replacement\n                    .replace(\"&lt;\", \"<\")\n                    .replace(\"&gt;\", \">\")\n                    .replace(\"&amp;\", \"&\");\n                html = html.replace(pattern, replacement);\n            }\n            return html;\n        },\n\n\n        /**\n         * Parse style string to object\n         * @param {string} str\n         * @return {Object}\n         * @example\n         * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\n         * console.log(stl);\n         * // {color: 'black', width: '100px', test: 'value'}\n         */\n        parseStyle(str) {\n            var result = {};\n            var decls = str.split(';');\n            for (var i = 0, len = decls.length; i < len; i++) {\n                var decl = decls[i].trim();\n                if (!decl) continue;\n                var prop = decl.split(':');\n                result[prop[0].trim()] = prop\n                    .slice(1)\n                    .join(':')\n                    .trim();\n            }\n            return result;\n        },\n\n        /**\n         * Parse class string to array\n         * @param {string} str\n         * @return {Array<string>}\n         * @example\n         * var res = ParserHtml.parseClass('test1 test2 test3');\n         * console.log(res);\n         * // ['test1', 'test2', 'test3']\n         */\n        parseClass(str) {\n            const result = [];\n            const cls = str.split(' ');\n            for (let i = 0, len = cls.length; i < len; i++) {\n                const cl = cls[i].trim();\n                if (!cl) continue;\n                result.push(cl);\n            }\n            return result;\n        },\n\n        toAttrArray(obj){\n            var attrArr = [];\n            Object.keys(obj).map(key => {\n                attrArr.push({'nodeName':key, 'nodeValue':obj[key]})\n            })\n            return attrArr;\n        },\n\n        /**\n         * Get data from the node element\n         * @param  {HTMLElement} el DOM element to traverse\n         * @return {Array<Object>}\n         */\n        parseNode(el) {\n            const result = [];\n            const nodes = el.childNodes;\n\n            for (var i = 0, len = nodes.length; i < len; i++) {\n                const node = nodes[i];\n\n                // DOM copmatibility\n                node.nodeValue = node.rawText;\n                node.content = node.rawText;\n\n                // Make attrs compatible with DOM representation\n                let attrs = [];\n                    attrs = (typeof node.attributes == 'object'\n                        ? this.toAttrArray(node.attributes)\n                        :  node.attributes)\n                        || []\n                    const attrsLen = attrs.length;\n                const nodePrev = result[result.length - 1];\n                const nodeChild = node.childNodes.length;\n                const ct = this.compTypes;\n                let model = {};\n\n                if (ct) {\n                    let obj = '';\n                    let type =\n                        node.getAttribute && node.getAttribute(`${modelAttrStart}type`);\n                    if (!type) {\n                        type = node.attributes && node.attributes[`${modelAttrStart}type`];\n                    }\n\n                    if (type) {\n                        model = { type };\n                    } else {\n                       \n                        for (let it = 0; it < ct.length; it++) {\n                            const compType = ct[it];\n                            obj = compType.model.isComponent(node);\n\n                            if (obj) {\n                                if (typeof obj !== 'object') {\n                                    obj = { type: compType.id };\n                                }\n                                break;\n                            }\n                        }\n\n                        model = obj;\n                    }\n                }\n\n                model.tagName = node.tagName;\n\n                if (attrsLen) {\n                    model.attributes = {};\n                }\n\n                for (let j = 0; j < attrsLen; j++) {\n                    const nodeName = attrs[j].nodeName;\n                    let nodeValue = attrs[j].nodeValue;\n                    // if (nodeName == \"formatValue\") {\n                    //     debugger;\n                    // }\n\n                    // Isolate attributes\n                    if (nodeName == 'style') {\n                        model.style = this.parseStyle(nodeValue);\n                    } else if (nodeName == 'class') {\n                        model.classes = this.parseClass(nodeValue);\n                    } else if (nodeName == 'contenteditable') {\n                        continue;\n                    } else if (nodeName.indexOf(modelAttrStart) === 0) {\n                        const modelAttr = nodeName.replace(modelAttrStart, '');\n                        const valueLen = nodeValue.length;\n                        const firstChar = nodeValue && nodeValue.substr(0, 1);\n                        const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\n                        nodeValue = nodeValue === 'true' ? true : nodeValue;\n                        nodeValue = nodeValue === 'false' ? false : nodeValue;\n\n                      \n                        try {\n                            nodeValue =\n                                (firstChar == '{' && lastChar == '}') ||\n                                (firstChar == '[' && lastChar == ']')\n                                    ? JSON.parse(nodeValue)\n                                    : nodeValue;\n                        } catch (e) {}\n\n                        model[modelAttr] = nodeValue;\n                    } else {\n                        model.attributes[nodeName] = nodeValue;\n                    }\n                }\n\n                if (nodeChild && !model.components) {\n                    const firstChild = node.childNodes[0];\n                    firstChild.nodeValue = firstChild.rawText;\n\n                    if (nodeChild === 1 && firstChild.nodeType === 3) {\n                        !model.type && (model.type = 'text');\n                        model.content = firstChild.nodeValue;\n                    } else {\n                        model.components = this.parseNode(node);\n                    }\n                }\n\n                if (model.type == 'textnode') {\n                    model.content = node.nodeValue;\n\n                    if (nodePrev && nodePrev.type == 'textnode') {\n                        nodePrev.content += model.content;\n                        continue;\n                    }\n\n                    if (!config.keepEmptyTextNodes) {\n                        const content = node.nodeValue;\n                        if (content != ' ' && !content.trim()) {\n                            continue;\n                        }\n                    }\n                }\n\n                \n                const comps = model.components;\n                if (!model.type && comps) {\n                    let allTxt = 1;\n                    let foundTextNode = 0;\n\n                    for (let ci = 0; ci < comps.length; ci++) {\n                        const comp = comps[ci];\n                        const cType = comp.type;\n\n                        if (\n                            ['text', 'textnode'].indexOf(cType) < 0 &&\n                            c.textTags.indexOf(comp.tagName) < 0\n                        ) {\n                            allTxt = 0;\n                            break;\n                        }\n\n                        if (cType == 'textnode') {\n                            foundTextNode = 1;\n                        }\n                    }\n\n                    if (allTxt && foundTextNode) {\n                        model.type = 'text';\n                    }\n                }\n\n                if (!model.tagName && model.type != 'textnode') {\n                    continue;\n                }\n\n                result.push(model);\n            }\n\n            return result;\n        },\n\n        /**\n         * Parse HTML string to a desired model object\n         * @param  {string} str HTML string\n         * @param  {ParserCss} parserCss In case there is style tags inside HTML\n         * @return {Object}\n         *\n         */\n        parse(str, parserCss) {\n            console.log(\"html\", str, parserCss);\n\n            var config = (c.em && c.em.get('Config')) || {};\n            var res = { html: '', css: '' };\n\n            var quoted = this.quoteJsxExpresionsInAttributes(str);\n            let wrappedInDiv = false;\n            if (!quoted.startsWith('<')) {\n                quoted = '<div>'+quoted+'</div>';\n                wrappedInDiv = true;\n            }\n            const dom = nodeHtmlParser(quoted);\n            var result = this.parseNode(dom);\n\n            if (result.length == 1) {\n                result = result[0];\n            }\n\n            if (wrappedInDiv) {\n                if (result.components) {\n                    result = result.components;\n                }\n                \n                else {\n                    delete result.tagName;\n                    result.type = \"textnode\";\n                }\n            }\n            res.html = result;\n\n           \n            if (parserCss) {\n                var el = document.createElement('div');\n                el.innerHTML = str;\n                var styleStr = '';\n                var styles = el.querySelectorAll('style');\n                var j = styles.length;\n\n                while (j--) {\n                    styleStr = styles[j].innerHTML + styleStr;\n                    styles[j].parentNode.removeChild(styles[j]);\n                }\n\n                if (styleStr) res.css = parserCss.parse(styleStr);\n            }\n\n            return res;\n        }\n    };\n};"]},"metadata":{},"sourceType":"module"}