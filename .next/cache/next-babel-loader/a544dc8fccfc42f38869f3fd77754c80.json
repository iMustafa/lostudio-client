{"ast":null,"code":"import { each, isString } from 'underscore';\nimport { parse as nodeHtmlParser } from \"node-html-parser\";\nimport XRegExp from \"xregexp\";\nwindow.nodeHtmlParser = nodeHtmlParser;\n/**\n * Parses an HTML string into its HTML and CSS component representation keeping case of tags and attributes. This\n * is necessary in case you want React compatible JSX tags in the template, in which case the react components must start\n * wih uppercase and also the camel casing of attributes is importane (ie. className vs classname)\n *\n * This function is based on src/parser/model/ParserHtml.js. For parsing we are using node-html-parser instead of\n * the browser's DOM to keep the case of tags and attributes. The code is mostly the same  as in ParserHtml.js\n * by maing the objects created by  node-html-parser compatible with the DOM representation.\n *\n * @param config usual grapesjs config\n * @returns parser function\n */\n\nexport default (config => {\n  var TEXT_NODE = 'span';\n  var c = config;\n  var modelAttrStart = 'data-gjs-';\n  return {\n    compTypes: '',\n    modelAttrStart,\n\n    /**\n     * Extract component props from an attribute object\n     * @param {Object} attr\n     * @returns {Object} An object containing props and attributes without them\n     */\n    splitPropsFromAttr(attr = {}) {\n      const props = {};\n      const attrs = {};\n      each(attr, (value, key) => {\n        if (key.indexOf(this.modelAttrStart) === 0) {\n          const modelAttr = key.replace(modelAttrStart, '');\n          const valueLen = value.length;\n          const valStr = value && isString(value);\n          const firstChar = valStr && value.substr(0, 1);\n          const lastChar = valStr && value.substr(valueLen - 1);\n          value = value === 'true' ? true : value;\n          value = value === 'false' ? false : value; // Try to parse JSON where it's possible\n          // I can get false positive here (eg. a selector '[data-attr]')\n          // so put it under try/catch and let fail silently\n\n          try {\n            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;\n          } catch (e) {}\n\n          props[modelAttr] = value;\n        } else {\n          attrs[key] = value;\n        }\n      });\n      return {\n        props,\n        attrs\n      };\n    },\n\n    /**\n     * Given a string with html (jsx). Attributes having JSX expressions will be quoted to look like\n     * actual HTML attributes\n     * @param {*} html\n     * @return html with quoted JSX attributes\n     *\n     * https://stackoverflow.com/questions/546433/regular-expression-to-match-balanced-parentheses\n     */\n    quoteJsxExpresionsInAttributes(html) {\n      let found = XRegExp.matchRecursive(html, \"{\", \"}\", \"g\");\n\n      for (let i = 0; i < found.length; i++) {\n        // (value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`\n        // --> {(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n        let pattern = \"{\" + found[i] + \"}\";\n        let lastStartPos = 0; // Find pattern until we reach and of html\n\n        while (true) {\n          let needsQuote = false; // get next match position\n\n          let matchPos = html.indexOf(pattern, lastStartPos);\n\n          if (matchPos === -1) {\n            break;\n          } // We will look back 1 and 2 characters\n\n\n          let oneCharBeforePos = matchPos - 1;\n          let twoCharBeforePos = matchPos - 2;\n\n          if (twoCharBeforePos > 0 && oneCharBeforePos > 0) {\n            // Need to quote if have sg like this:\n            //   formatValue={(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\n            // (ie: if patterns comes atfre and equals sime, but not =\")\n            // But no need to quote if:\n            //    formatValue=\"{(value) => \\`\\${(value) => < 10 ? \\`0\\${value}\\` : value)}\\`}\"\n            //    <Timer.Days/>{this.model.attributes.displayLabels ? \" \"+this.model.attributes.labels.labelDays+\" \" : ', '}\n            needsQuote = html.substring(twoCharBeforePos, twoCharBeforePos + 2) !== '=\"' && html.substring(oneCharBeforePos, oneCharBeforePos + 1) === \"=\";\n          } // If need to quote: replace patterns with quoted version also escaping some HTML entities\n\n\n          if (needsQuote) {\n            let replacement = '\"{' + found[i].replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"&\", \"&amp;\") + '}\"';\n            html = html.replace(pattern, replacement);\n            lastStartPos = matchPos + replacement.length;\n          } else {\n            lastStartPos = matchPos + pattern.length;\n          } // No lastStartPos placed after the processed string\n\n        }\n      }\n\n      return html;\n    },\n\n    /**\n     * Unquote attributes containg JSX previously quoted using quoteJsxExpresionsInAttributes\n     * @param html\n     */\n    unquoteJsxExpresionsInAttributes(html) {\n      let found = html.match(/=[\"']{.*}[\"']/g);\n\n      if (!found) {\n        return html;\n      }\n\n      for (let i = 0; i < found.length; i++) {\n        let pattern = found[i];\n        let replacement = pattern.startsWith('=\"{') ? pattern.replace('\"{', \"{\").replace('}\"', \"}\") : pattern.replace(\"{'\", \"{\").replace(\"}'\", \"}\");\n        replacement = replacement.replace(\"&lt;\", \"<\").replace(\"&gt;\", \">\").replace(\"&amp;\", \"&\");\n        html = html.replace(pattern, replacement);\n      }\n\n      return html;\n    },\n\n    /**\n     * Parse style string to object\n     * @param {string} str\n     * @return {Object}\n     * @example\n     * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');\n     * console.log(stl);\n     * // {color: 'black', width: '100px', test: 'value'}\n     */\n    parseStyle(str) {\n      var result = {};\n      var decls = str.split(';');\n\n      for (var i = 0, len = decls.length; i < len; i++) {\n        var decl = decls[i].trim();\n        if (!decl) continue;\n        var prop = decl.split(':');\n        result[prop[0].trim()] = prop.slice(1).join(':').trim();\n      }\n\n      return result;\n    },\n\n    /**\n     * Parse class string to array\n     * @param {string} str\n     * @return {Array<string>}\n     * @example\n     * var res = ParserHtml.parseClass('test1 test2 test3');\n     * console.log(res);\n     * // ['test1', 'test2', 'test3']\n     */\n    parseClass(str) {\n      const result = [];\n      const cls = str.split(' ');\n\n      for (let i = 0, len = cls.length; i < len; i++) {\n        const cl = cls[i].trim();\n        if (!cl) continue;\n        result.push(cl);\n      }\n\n      return result;\n    },\n\n    toAttrArray(obj) {\n      var attrArr = [];\n      Object.keys(obj).map(key => {\n        attrArr.push({\n          'nodeName': key,\n          'nodeValue': obj[key]\n        });\n      });\n      return attrArr;\n    },\n\n    /**\n     * Get data from the node element\n     * @param  {HTMLElement} el DOM element to traverse\n     * @return {Array<Object>}\n     */\n    parseNode(el) {\n      const result = [];\n      const nodes = el.childNodes;\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i]; // DOM copmatibility\n\n        node.nodeValue = node.rawText;\n        node.content = node.rawText; // Make attrs compatible with DOM representation\n\n        let attrs = [];\n        attrs = (typeof node.attributes == 'object' ? this.toAttrArray(node.attributes) : node.attributes) || [];\n        const attrsLen = attrs.length;\n        const nodePrev = result[result.length - 1];\n        const nodeChild = node.childNodes.length;\n        const ct = this.compTypes;\n        let model = {};\n\n        if (ct) {\n          let obj = '';\n          let type = node.getAttribute && node.getAttribute(`${modelAttrStart}type`);\n\n          if (!type) {\n            type = node.attributes && node.attributes[`${modelAttrStart}type`];\n          }\n\n          if (type) {\n            model = {\n              type\n            };\n          } else {\n            for (let it = 0; it < ct.length; it++) {\n              const compType = ct[it];\n              obj = compType.model.isComponent(node);\n\n              if (obj) {\n                if (typeof obj !== 'object') {\n                  obj = {\n                    type: compType.id\n                  };\n                }\n\n                break;\n              }\n            }\n\n            model = obj;\n          }\n        }\n\n        model.tagName = node.tagName;\n\n        if (attrsLen) {\n          model.attributes = {};\n        }\n\n        for (let j = 0; j < attrsLen; j++) {\n          const nodeName = attrs[j].nodeName;\n          let nodeValue = attrs[j].nodeValue; // if (nodeName == \"formatValue\") {\n          //     debugger;\n          // }\n          // Isolate attributes\n\n          if (nodeName == 'style') {\n            model.style = this.parseStyle(nodeValue);\n          } else if (nodeName == 'class') {\n            model.classes = this.parseClass(nodeValue);\n          } else if (nodeName == 'contenteditable') {\n            continue;\n          } else if (nodeName.indexOf(modelAttrStart) === 0) {\n            const modelAttr = nodeName.replace(modelAttrStart, '');\n            const valueLen = nodeValue.length;\n            const firstChar = nodeValue && nodeValue.substr(0, 1);\n            const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\n            nodeValue = nodeValue === 'true' ? true : nodeValue;\n            nodeValue = nodeValue === 'false' ? false : nodeValue;\n\n            try {\n              nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;\n            } catch (e) {}\n\n            model[modelAttr] = nodeValue;\n          } else {\n            model.attributes[nodeName] = nodeValue;\n          }\n        }\n\n        if (nodeChild && !model.components) {\n          const firstChild = node.childNodes[0];\n          firstChild.nodeValue = firstChild.rawText;\n\n          if (nodeChild === 1 && firstChild.nodeType === 3) {\n            !model.type && (model.type = 'text');\n            model.content = firstChild.nodeValue;\n          } else {\n            model.components = this.parseNode(node);\n          }\n        }\n\n        if (model.type == 'textnode') {\n          model.content = node.nodeValue;\n\n          if (nodePrev && nodePrev.type == 'textnode') {\n            nodePrev.content += model.content;\n            continue;\n          }\n\n          if (!config.keepEmptyTextNodes) {\n            const content = node.nodeValue;\n\n            if (content != ' ' && !content.trim()) {\n              continue;\n            }\n          }\n        }\n\n        const comps = model.components;\n\n        if (!model.type && comps) {\n          let allTxt = 1;\n          let foundTextNode = 0;\n\n          for (let ci = 0; ci < comps.length; ci++) {\n            const comp = comps[ci];\n            const cType = comp.type;\n\n            if (['text', 'textnode'].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {\n              allTxt = 0;\n              break;\n            }\n\n            if (cType == 'textnode') {\n              foundTextNode = 1;\n            }\n          }\n\n          if (allTxt && foundTextNode) {\n            model.type = 'text';\n          }\n        }\n\n        if (!model.tagName && model.type != 'textnode') {\n          continue;\n        }\n\n        result.push(model);\n      }\n\n      return result;\n    },\n\n    /**\n     * Parse HTML string to a desired model object\n     * @param  {string} str HTML string\n     * @param  {ParserCss} parserCss In case there is style tags inside HTML\n     * @return {Object}\n     *\n     */\n    parse(str, parserCss) {\n      console.log(\"html\", str, parserCss);\n      var config = c.em && c.em.get('Config') || {};\n      var res = {\n        html: '',\n        css: ''\n      };\n      var quoted = this.quoteJsxExpresionsInAttributes(str);\n      let wrappedInDiv = false;\n\n      if (!quoted.startsWith('<')) {\n        quoted = '<div>' + quoted + '</div>';\n        wrappedInDiv = true;\n      }\n\n      const dom = nodeHtmlParser(quoted);\n      var result = this.parseNode(dom);\n\n      if (result.length == 1) {\n        result = result[0];\n      }\n\n      if (wrappedInDiv) {\n        if (result.components) {\n          result = result.components;\n        } else {\n          delete result.tagName;\n          result.type = \"textnode\";\n        }\n      }\n\n      res.html = result;\n\n      if (parserCss) {\n        var el = document.createElement('div');\n        el.innerHTML = str;\n        var styleStr = '';\n        var styles = el.querySelectorAll('style');\n        var j = styles.length;\n\n        while (j--) {\n          styleStr = styles[j].innerHTML + styleStr;\n          styles[j].parentNode.removeChild(styles[j]);\n        }\n\n        if (styleStr) res.css = parserCss.parse(styleStr);\n      }\n\n      return res;\n    }\n\n  };\n});","map":null,"metadata":{},"sourceType":"module"}